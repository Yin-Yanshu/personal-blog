---
title: 笔记 5
date: 2025-01-12T20:10:00+08:00
updated: 2025-06-03T20:10:00+08:00
keywords: ["hello", "world"]
featured: true
summary: "这篇文章包含笔记内容。"
---

# 笔记 5

## 2025.1.12

了解到 docker 容器相关知识，基础概念 image（镜像），container（容器），Dockerfile，docker-compose.yml，volumes（数据卷）  
Dockerfile 用于编写将程序构建为 image 的脚本，例如

  ```yml
  FROM node:16-alpine as build-stage
  WORKDIR /app
  COPY . ./
  pnpm install
  EXPOSE 3000
  CMD ["node", "app.js"]
  ```

通过自动化脚本构建一个 node 容器并运行相关程序  
docker-compose.yml 用于编写在容器启动一系列镜像的自动化脚本,例如

  ```yml
  services:
    mile:
      image: mile
      volumes:
        - C:/mile/mile.jar:/app/mile.jar
      depends_on:
        - postgres
      ports:
        - "8081:8081"
    postgres:
      image: postgis/postgis
      ports:
        - "5432:5432"
      volumes:
        - C:/mile/pgdata:/var/lib/postgresql/data
  ```

编写了启动 mile postgis 镜像所需操作，实现自动化启动容器  

volumes（数据卷），将 docker 容器目录与主机目录进行关联，类似共享文件夹，容器运行产生数据实际存储在 columnes 映射的主机目录中，可实现文件持久化存储，删除镜像时不会将 volumnes 删除。  

```yml
volumes:
	  - C:/mile/pgdata:/var/lib/postgresql/data
```

原则上一个容器运行一个镜像实现程序隔离，各容器通过端口映射让外部访问。  
容器可使用 docker 的网络桥接实现容器间信息通讯。因为 docker 设计为隔离各个程序，所以比如 springboot 项目访问本地 localhost:5432 端口的 postgis 数据库在 docker 中无法实现，在 docker 中访问到的是 springboot 容器中的 5432 端口，无法访问 postgis 容器的端口，所以需要网络桥接实现容器通讯。

## 1.13

了解 ../  ./  /  . 的差别分别为转到父目录 当前目录 项目根目录 当前目录  

    project/
    ├── public/
    │   ├── logo.png
    ├── src/
    │   ├── api/
    │   │   ├── test.ts
    │   ├── components/
    │   │   ├── test.vue
    └── config/
    
/ 表示 project 根目录。/src/components/xxx.vue 使用绝对路径  
./ 和 . 的差别  ./ 访问当前目录下的 xx 文件  . 为当前目录下的所有文件  

了解 import 导入规则，建议 public 文件夹下静态资源使用绝对路径 /resource/xxx.png 方式导入。  
src 文件夹下 js，vue，png 模块都使用相对路径导入或别名路径 import 导入。  

vite 文档中提示，引入 public 中的资源永远应该使用根绝对路径  
举个例子，  
public/icon.png 应该在源码中被引用为 /icon.png。
public 中的资源不应该被 JavaScript 文件引用。即不应使用 import 导入 public 静态资源。  

使用 import logo form ’./assets/logo.png' 引入的 logo 得到的是资源路径字符串

## 1.30

了解到 RSA 非对称加密算法，sha256 (safety hash algorithm) md5 等 hash 算法，aes (advance e standard) 对称加密算法 des (data e standard)  

hash 算法具有无穷输入对应有穷输出，即输出结果为固定长度。输入相同一定输出相同。  
为什么具有这些特性的算法称为 hash，这个单词和这些概念有什么关系。  
hash 算法，也被称为摘要算法？可以用于检验数据是否被更改，因为输入改变一定回改变输出  

2025.3.17 补充，  
hash 值可以理解为一种数据指纹，因为不同的输入数据应该产生不同的 Hash 值；即使是输入数据的微小改变也会导致完全不同的 Hash 值。类比为每人都有指纹，但没有人指纹完全相同。  

redis （remote dictionary server）从名字可以看出 redis 就是个大键值对，可满足大量数据快速的查找。

## 2.25

  ```javascript
    class Person {
      constructor(name) {
          this._name = name; // 使用下划线前缀暗示这是一个私有属性，但js中还是可以直接访问_name，只是一个约定
      }
      get name() {
        return this._name;
      }
      set name(newValue) {
        if (typeof newValue === 'string') {
          this._name = newValue;
        } else {
          console.error('Name must be a string.');
        }
      }
    }

    const person = new Person('Alice');
    console.log(person.name);
  ```

了解到 js 中的 get set 语法，控制属性的安全访问和赋值。通过.符号访问修改的属性被 get/set 包裹，确保安全的访问和赋值。  
比如可控制输入数据类型，但 js 中也可以直接访问 _name 属性，get/set 的安全能力一般。  
在 JAVA 中@Data 注解为私有属性提供 getter，setter。提供安全访问能力。

## 2.27

阅读 vue 官方文档，详细再次了解一些基础指令的差异。  
v-bind，使父组件数据单向流入到子组件，子组件修改不会影响父组件。  
v-on，使子组件向父组件发送数据，父组件接收数据并进行处理，同样是单向数据流动。  
v-model，双向数据绑定，父子组件任意任意修改绑定变量，都会影响到父组件和子组件。  
v-model 为 v-bind 和 v-on 的语法糖，对一个 tableResult 变量双向绑定 v-model="tableResult"，  
即将 tableResult 使用 v-bind="tableResult" 将数据单向传入子组件  
再将 tableResult 使用 v-on="tableResult=(result)=>{ tableResult = result }" 将子组件数据单向返回给绑定对象，实现数据的双向修改。  
默认情况下 v-model="tableResult"   
传入子组件的属性默认名为 const props = defineProps(['modelValue']);  
返回事件名为 const emit = defineEmits(['update:modelValue']);  
所以默认情况下子组件使用 modelValue 接收数据，使用 update:modelValue 发送数据。  

如果想双向绑定多个变量，如  
```html
<tree
  v-model:expandedKeys="fatherExpandedKeys"
  v-model:selectedKeys="fatherSelectedKeys"
  v-model:checkedKeys="fatherCheckedKeys"
/>
```

  ```javascript
  const props = defineProps({
    expandedKeys: Array,
    selectedKeys: Array,
    checkedKeys: Array,
    treeData: Array
  });
  const emit = defineEmits([
    'update:expandedKeys',
    'update:selectedKeys',
    'update:checkedKeys'
  ]);
  ```

分别定义三个属性/事件，实现三个变量的双向绑定。  

从多个 v-model 绑定可以看出，实际上还是分别操作父子组件中对象，只是父子组件对象间数据同步的操作由语法糖封装。  

阅读了 React 官方文档，感觉 React 似乎更加简洁，并没有 vue 中过多的 v-if v-for v-bind v-on 语法，html 的判断和操作部分都使用 js 语法生成。  
所有的响应式操作，生命周期钩子 watch computed 都通过 useXXX 函数完成，更加偏向函数式编程。

## 3.4

  ```javascript
  function changeSelectFeatureStyle(layer, callback) {
    const defaultStyle = layer.getStyle();
    callback(defaultStyle);
  },

  function printSTyle(style) {
    console.log(style);
  }


  function usePagination(callback) {
    callback()
  }

  function refresh(params?) {
    if(params) {
      console.log('params')
    }
    console.log('refresh')
  }

  changeSelectFeatureStyle(printSTyle)
  usePagination(()=>refresh())
  ```

以上两个函数都将一个函数作为参数传递给另一个函数以便在特定条件下调用。changeSelectFeatureStyle 接收一个函数指针，在内部调用时如果 callback 需要入参则 changeSelectFeatureStyle 需要准备参数，callback 和 changeSelectFeatureStyle 有一定的耦合。  
usePagination 同样接收一个函数指针，但由于是一个没有入参的回调，所以在内部调用时无需入参，不必关心 callback 的执行细节只需调用，usePagination 和 refresh 没有耦合。

## 3.6

了解函数副作用的概念，函数副作用指函数执行过程中除了返回值之外的其他操作，如修改外部变量，io 操作等  
对应的函数主作用概念，为期望函数执行的核心功能，通过函数返回值接收主作用结果，对于外部获取的返回值，其他一切对外界的影响都称为副作用
	2025.10.16
	简单理解为在函数作用域内改变作用域外部变量则称有副作用(Side Effect)

  ```javascript
  let sourceArray = [1, 2, 3, 4];
  let targetList = [];

  sourceArray.forEach(function(item) {
      targetList.push(item * 2); // 这行代码是副作用,影响到外部变量
  });

  let sourceArray = [1, 2, 3, 4];
  let targetList = sourceArray.map(item => item * 2); // 这行代码是主作用，只影响返回值，不修改外部变量
  ```


## 3.16

import xx from 'xxx' 为 es6 语法，默认情况只支持导入 js，ts 模块。那 .jpg 等静态资源是如何加载？  
在 vite 中导入图片被处理为导入图片路径地址字符串。但也只支持一些常见静态资源类型，如可视化领域的 glsl，tif f 等文件似乎无法处理，需引入特定插件或在需要使用的地方写死引用路径地址而不使用 import 变量。  

静态资源可以存放在 public 或 src/asset 中，有什么区别？
生产环境中只可以直接通过路径访问 public 文件夹下的资源
访问 src/asset 中资源要使用 import 导入

首次开始刷 LeetCode，目前还不清楚刷算法题的意义，实际项目中并未碰到应用场景，目前的支撑论点为为以后转 web3 可能会碰到的复杂数据结构场景做铺垫。  
不了解常见的编码套路确实属于两眼一抹黑的乱写，有一种民科的感觉，随意出现一个想法，完全不清楚设计逻辑是否有计算出结果的可能性就直接开始乱写。除了使用循环，判断，目前还完全不能独立设计出一些常见的解题数据结构，如二分查找，链表等。  
如果说把数据结构算法类比为电子数学题，似乎先了解常见的出题类型，解题方法，可能会有更高的解题效率。

## 3.19

了解结算，清算概念。

## 3.20

了解 requireJS，之前不理解这个库的定位，还奇怪这是什么 js 库怎么从来没用过。在定位上 requireJS 和 import export 等 ES6 Modules 导入导出为同一功能定位，用于依赖管理和模块管理。requireJS 使用 AMD 标准，import export 为 ES6 Modules 原生模块系统。  

了解到 requireJS 其实和原生 js 开发区别不大，只是能自动处理模块之间的依赖关系，无需考虑加载顺序，但本质上还是一种命令式编程，需要手动操作 DOM。相比于 react，vue 等现代前端框架的声明式编程范式还是过于原始。  
如何区别命令式编程和声明式编程？命令式编程需要逐个步骤指定操作逻辑并手动处理。  

了解 bootstrap.yml 的命名逻辑。bootstrap 原意是指“引导”或“启动”，bootstrap.yml 可理解为通过引导，配置启动一个工程。文件命名和功能对应。 bootstrap.yml 常用于启动 Spring Cloud 功能的配置文件和 bootstrap.css 这个前端框架是两个东西。  

终于区分 MVC 架构和前后端分离架构的区别。之前以为 MVC 架构就是创建一个叫 Spring MVC 的工程，以为和 Springboot 类似是一个开箱即用的框架，今天详细了解后发现 MVC 架构是一种功能分离思想，但本质是服务端驱动渲染。View 层由服务器端生成，当客户端请求一个页面时，服务器会处理请求，执行业务逻辑，将结果通过模板引擎（如 FreeMarker、Thymeleaf 或 JSP）渲染成 HTML 格式并返回给客户端，是一种服务端渲染，前端依赖于后端无法独立运行。前后端分离架构则很常见了，将渲染完全分离出来，通过 json 和网络接口进行数据交互，是一种客户端渲染。（今天才发现国基平台除了三维一张图部分其他都使用 MVC 架构进行构建，门户首页，系统配置页面等都使用如 FreeMarker 模板渲染，前后端混在一起并且和原生 html 类似的写法感觉有点过时，不过可能项目最初启动时 vue 还没火起来吧。）

## 3.21

了解 js 中 !! 双非判断符，就是连续使用两个非处理，可以将任意类型转换为布尔类型。第一个 ! 将任意类型转 Boolean 并取反，第二个 ! 再次取反，最终获取任意类型的 Boolean 值。但这个写法可读性一般，使用 Boolean 静态方法似乎更好一些。

## 3.25

OOP 和 FP 编程范式的差异，似乎重数据的部分 OOP 更合理，重行为的部分 FP 更合理

### OOP  

- 通过继承 extends 实现代码重用
- 将对象的属性和方法结合在一起，数据和行为耦合。方法更可能直接改变数据状态。

``` java
// 基类 Animal
class Animal {
    public void speak() {
        System.out.println("动物叫");
    }
}

// 子类 Dog
class Dog extends Animal {
    private int speakNum = 0;
    @Override
    public void speak() {
        System.out.println("狗叫");
        speakNum += 1;
    }
}

public class Main {
    public static void main(String[] args) {
        Animal dog = new Dog();
        dog.speak(); // 输出: Woof 1!
        dog.speak(); // 输出: Woof 2!
    }
}
```

OOP 示例中数据和行为耦合，方法会更改状态，继承实现代码复用。

### FP

- 通过组合实现代码重用
- 强调数据和行为的分离。
- 函数的输出完全依赖于输入，不依赖于或修改外部状态。输出更可控，减少副作用。
- 数据创建后不能被修改，修改数据会产生新的数据副本。即处理后返回新值。

``` go
package main
import "fmt"

// 定义一个接口，表示可以发声的行为
type Speaker interface {
    Speak() string
}

// 定义具体的发声行为
type Dog struct{}

func (d Dog) Speak() string {
    return "Woof!"
}

// 定义一个通用的动物结构体，可以组合不同的行为
type Animal struct {
    Speaker // 组合接口
}

func main() {
    dog := Animal{Speaker: Dog{}}
    fmt.Println(dog.Speak()) // 输出: Woof!
}
```

FP 示例数据行为分离，方法输出由输入决定且不影响外部状态，组合实现代码复用。  

### 一等公民

一等公民（First-class citizen）是一种编程理论术语。指在某一编程语言中具有以下特性的实体：

可以**赋值**给变量：该实体可以被存储在一个变量中。  
可以作为参数**传递**给函数：该实体可以被当作参数传递给其他函数。  
可以从函数**返回**：该实体可以作为另一个函数的返回值。  
可以在数据结构中**存储**：该实体可以作为数组、列表或其他数据结构的元素。  

**总结为如果一类实体可以和基本类型（如浮点数、布尔值等）具有同等的操作权限和灵活性则可称为一等公民。**  

为什么命名为一等公民，性质和名字有什么联系吗?  
命名为“一等公民”主要是强调这些元素具有最高级别的灵活性而没有任何特殊限制。" 二等公民 " 可能在某些操作上受到限制（如在 java 中函数，控制语句 if， while 等不能作为参数传递或从函数返回）。所以也可推断任意语言的基本类型都是一等公民 。较现代的语言（如 go，rust，Kotlin）都对函数有较高权限的支持。  

java 等传统 OOP 设计的语言中，不支持直接传递或返回一个函数

``` java
@FunctionalInterface
interface MathOperation {
    int operate(int a, int b);
}

public class Main {
    public int executeOperation(MathOperation operation, int a, int b) {
        // 需调用对象的operate方法才能执行传入函数，无法直接运行传入函数
        return operation.operate(a, b); 
    }
    public void main(String[] args) {
        MathOperation add = (a, b) -> a + b; // 使用Lambda表达式
        System.out.println(executeOperation(add, 5, 3)); // 输出: 8
    }
}
```

javascript 中支持函数的赋值，调用，传递

``` javascript
function add(x, y) {
    return x + y;
}

function executeOperation(operation, a, b) {
  // 直接调用传入的函数
  return operation(a, b);
}

console.log(executeOperation(add, 5, 3)); // 输出: 8
```

## 4.4

当函数在其声明的作用域之外执行时，会形成闭包。
闭包使函数不在定义的作用域内被调用，但是仍然可以访问作用域中的变量。
可以防止变量被污染。  
让变量的值始终保持在内存中，使函数具有保持状态的能力。
```javascript
function createCounter() {
    let count = 0; // 外部变量
    return () => { // 返回的内部函数
        count++; // 内部函数引用外部变量
        return count;
    }
}

const counter = createCounter();
console.log(counter()); // 输出: 1
console.log(counter()); // 输出: 2
```

## 4.5

学习 solidity 语法  
boss 上看区块链招聘到底要什么技术，写的很模糊，大概分为掌握 solidity 能写智能合约，后端 go。基建涉及到一些 rollup 性能优化 。传统前端开发 web3 项目   
wtf academy 学习 solidity 语法，了解以太坊常见标准，基本掌握后大概有合约开发能力。还有部分章节介绍具体功能的代码实现，如空头发币合约，线性释放合约，多签钱包合约的实现。  
初步编了一份 web3 简历  
了解到一些 web3 网站，如 Mirror，follow 郭宇较详细介绍了入门 web3 知识体系  
了解到 OpenZeppelin 似乎和 ant design 组织一样，下面管理很多优秀开源基础库  
尝试了解 unswap 经济模型和源码但进展较慢，目前似乎还不是很理解 uniswap 的具体原理

## 4.6

了解几个 react native ui 库 react native paper；react native element；NativeBase

## 5.4

在 URI 资源定位中，结尾添加 “/” 倾向于表示资源目录。
如 https://example.com/images/表示存放照片目录。https://example.com/images/articles/picture.jpg 结尾不添加 “/” 表示具体某一资源。
但这并不是绝对的，最终的含义还是由服务器端的配置和应用程序的逻辑来确定。

## 5.21

了解 hardhat 框架在合约开发中的作用 
了解 OpenZeppelin 提供一些验证安全的合约接口，可基于此重写
了解一些区块链浏览器，可查看链上公开信息。Etherscan，以太坊生态浏览器。Blockchair 多币种区块链浏览器。BscScan，币安智能链浏览器。

## 6.3

React 生态中对于 CSS 样式隔离常见有 CSS-in-JS 方案和 CSS Moudule 方案。
CSS-in-JS 方案在 JS 中直接编写样式代码并通过变量名绑定至 DOM。运行时生成样式，运行时将 JS 对象中 CSS 代码转为 CSS 字符串注入到 style 标签中并为类名和 DOM 中 className 绑定相同类名添加相同 hash 值，时 DOM 中 class 和 css 中匹配。运行时生成样式，可能影响首屏加载。
CSS Module 方案使用 moudle.css 标记为局部样式并通过变量名绑定至 DOM。编译时对类名进行哈希处理保证样式隔离，无运行时开销。和 Vue 生态中 scope 语法糖为类似解决方案。
