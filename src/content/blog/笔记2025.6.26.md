---
title: 笔记2025.6.26
date: 2025-04-05T20:10:00+08:00
updated: 2025-04-05T20:10:00+08:00
keywords: ["hello", "world"]
featured: true
summary: "这篇文章包含笔记2025.6.26基本的内容。"
---

## 6.26

```jsx
function Counter() { 
  const [number, setNumber] = useState(0); 
  useEffect(() => { 
	  // 仅在渲染后执行
	  console.log('useEffect 执行时 number:', number);  
  }, [number]); 
  return ( 
    <button onClick={() => { 
	  console.log('点击前 number:', number); // 0 
	  setNumber(number + 1); 
	  setNumber(number + 1); 
	  console.log('点击后 number:', number); // 0 
	}}>+1</button> 
  ); 
}
```

click 事件后执行 console 执行，setNumber 执行提示 React 状态发送改变，console 执行，重新渲染执行 Counter 组件，const [number, setNumber] = useState 返回更新后的 number 值为 1。所以多次执行 setNumber 获取的当前 number 都为 1

setNumber(number+1) 不改变 number 值，number 由 useState 改变并返回。所以在 useState 所在组件未被重新执行前获取 number 的值都不变。 

`useState` 引起 React 重新渲染，useRef 不引起 React 重新渲染但可以保存状态，如 setTimeOut 需要在重新渲染时保留以便在需要时清除，还可通过 `useRef` 操作 DOM 元素。 

computed 和 `useMemo` 使用场景相同，缓存计算结果。但 computed 自动追踪依赖，而 React 的 useMemo 需要手动声明依赖项。 useMemo 调用函数并缓存结果， `useCallback` 缓存函数本身。

`useEffect` 提供 Vue 中多个函数功能

| **React 特性**                 | **Vue 等价功能**              | **说明**                  |
| ---------------------------- | ------------------------- | ----------------------- |
| `useEffect(() => {}, [])`    | `onMounted`               | 挂载后执行，用于初始化资源。          |
| `useEffect(()=>{return},[])` | `onBeforeUnmount`         | 卸载前执行清理逻辑（如取消订阅、清除定时器）。 |
| `useEffect(() => {})`        | `onMounted` + `onUpdated` | 每次渲染后执行。                |
| `useEffect(() => {}, [dep])` | `watch`                   | 监听特定依赖变化。               |
为什么 useEffect 集中这么多不同功能？

try catch finally 包裹网络请求，作为请求失败兜底处理。
```typescript
// 考虑接口数据返回为空时默认值处理
const response = await getBlueHoldActivities();
const processedActivities = (response.activities || []).map((activity) => {
	return {
	  ...activity,
	  status: statusInfo.status,
	};
});

// 网络请求使用try catch包裹兜底
try {
  const response = await getSnapshotResults();
  setSnapshotDialog((prev) => ({
	...prev,
	data: response.snapshots || [],
  }));
  // 考虑接口数据返回为空时默认值处理
  toast.success(`快照结果获取成功，共${response.total || 0}条记录`);
} catch (error) {
  toast.error("获取快照结果失败");
}
```

## 6.30

tailwindcss 中工具栏 `响应式断点` 写法和 `基础类` 写法有部分重合。 
响应式断点前缀提供预设容器查询大小
- `sm`: 640px（小屏幕）。当视窗宽度大于等于 640px 时生效。
- `md`: 768px（中等屏幕）。当视窗宽度大于等于 768px 时生效。
- `lg`: 1024px（大屏幕）。当视窗宽度大于等于 1024px 时生效。
- `xl`: 1280px（超大屏幕）。当视窗宽度大于等于 1280px 时生效。
- `2xl`: 1536px（超大屏幕）。当视窗宽度大于等于 1536px 时生效。
md:grid-cols-2， md:flex

作为基础类中一部分提供预设圆角，字体大小
rounded-xl， text-md

## 7.11

了解 curl(Client URL) 命令是一种发起 HTTP 请求的命令行

## 7.31

遇到 react useCallback useEffect 循环依赖问题

``` jsx
<FlatList
  data={data}
  renderItem={renderItem}
/>

const renderItem = useCallback(({ item, index }) => {
  return <ItemComponent item={item} index={index} />;
}, []);
```
所有 renderItem 都建议使用 useCallback 包裹提高性能

## 8.5

了解 TailwindCSS 工作原理。TailwindCSS 样式代码在编译时期生成，大致工作流程为 
扫描指定文件路径下所有文件，通过正则表达式获取使用了哪些工具类
将工具类对应的 CSS 样式合并到一个 CSS 文件中，类名为工具类名称
运行时元素类名和 CSS 文件中类名匹配并应用对应样式

TailwindCSS 中谨慎使用动态工具类，下面示例在运行时拼接工具类 className=“bg-['#ffffff']”，看似正确的工具类，设置背景色为白色，但运行时样式未生效。因为编译时 TailwindCSS 未将工具类 bg-['#ffffff'] 生成对应 CSS 样式，导致运行时没有匹配类名无法生效样式。如果要动态生成工具类，先确保在编译时这个工具类已经生成对应 CSS 样式。
``` jsx
const colorMap = { 
  default: { primary: '#ffffff', secondary: '#ffffff'}, 
  positive: { primary: '#ffffff', secondary: '#166534'},
}
<View className={`bg-[${colorMap.default.primary}]`} />
```

## 8.7

TanStack Query 本质上是数据请求层的**全局缓存管理器**，解决的是后端数据（列表、详情、表单提交数据）在多组件间的同步问题。TanStack Query 仅通过 queryKey 即可实现跨组件的数据同步，无需手动编写状态更新逻辑，大幅减少样板代码。
Zustand 等状态库解决的是前端本地状态（如 UI 状态、权限开关）的全局共享问题。

## 8.15

Expo 热更新原理，上传更新代码到 EAS 服务器，软件端调用 Expo 提供 Update 库检查是否需要更新，并下载更新 js 代码和静态资源。 
为什么原生代码不能热更新？移动操作系统安全机制禁止动态更新原生模块，应用在发布前都必须由开发者用一个私钥进行**数字签名**，证明应用来自可信的开发者，并且自签名后没有被篡改。并且.apk 是只读的，不允许被修改。 若动态更新原生模块会导致签名结果不一致，需要重新上架审核。 
为什么 js 代码可以热更新？
在打包软件为 apk 时 js 代码同样在签名文件夹中，更新 js 代码会导致签名改变吗？ 
更新 js 代码不会将文件写入 apk 内部，而是存放在 apk 创建的私有目录中，所以更新的 js 代码没有改变 apk 内容，后续只运行位于私有目录中的更新代码。

## 8.16

### TailwindCSS 等原子类 CSS 设计范式

#### TailwindCSS 和 Boostrap 对比 
Bootstrap 采用**组件优先**（Component-First）理念。提供预设样式的 UI 组件库（如按钮、卡片、导航栏、模态框等）。可以直接使用这些组件来快速搭建界面。Bootstrap 提供的
Tailwind CSS 采用**实用优先**（Utility-First）理念。提供大量单一职责的工具类（Utility Classes），通过**组合**这些工具类来构建出 UI。

#### TailWind 中@apply 和 Boostrap 中预设样式对比
``` css
// TailWind的@apply
.btn-lg {
  @apply px-6 py-3 text-lg bg-black
}

// Boostrap的预设按钮样式
.btn {
  text-decoration: none;
  vertical-align: middle;
  user-select: none;
  border: 1px solid transparent;
}
```

```html
// Boostrap样式使用
<button class="btn btn-primary">按钮</button>
// Tailwind @apply使用
<button class="btn-lg rounded-lg flex-row justify-center">按钮</button>
```
`@apply` 和 Boostrap 都预设了一套组件的样式，使用预设的类名可以直接组合出固定 ui 样式，过度封装自定义 `@apply` 则将 Tailwind 用回了 Boostrap，**失去其原子化、轻量化的本质**。

#### 如何避免 Tailwind 被用成 Bootstrap？
- 只封装高频 + 稳定的 UI，全局统一，极少变化。
- 封装的是“设计系统层级”的组件，不是“页面层级”的样式。如.btn-primary .input-base，在不同页面中使用按钮，输入框时希望展现相同样式。
- 避免封装可组合的原子类。
``` css
.btn-primary-hover-scale {
  @apply bg-blue-600 text-white hover:scale-105;
}
```
hover 是一个可组合的样式，不应封装在@apply 中，在需要时可以组合类名将 hover 效果添加。

#### 是封装 Tailwindcss 自定义类名还是用 tailwindcss 类名封装公共组件？——Tailwind 使用范式
- 一次性样式，直接用原子类。
- `@apply` 中封装极少数、最基础的样式，目的是**减少重复的原子组合，不是替代组件**。
- 在公共组件中使用原子类组合样式（主要应用）。

问题的本质是，样式抽象 和 UI 抽象，应该在哪个层级进行？
结论为**建议优先封装为公共组件**。**用原子类构建组件，而不是用原子类构建页面**。过度使用 `@apply` 会失去 Tailwind 的优势。

## 8.26

`React.ReactNode` 和 `JSX.Element` 区别。 
`React.ReactNode` 表示**任何可以被渲染的东西**，在定义组件的 `children` 属性或组件的返回类型时，优先使用 `React.ReactNode`
`JSX.Element` 表示**一个具体的 JSX/React 元素**，只有在需要强制要求是单个元素时，才考虑使用 `JSX.Element`。

## 8.27

### Reat Fiber 架构 

React15 的架构局限性。在 React 15 及之前，协调（Reconciliation）过程是**递归、同步、不可中断**的,更新流程像一次深度优先遍历。 
一个大型列表组件（比如 1000 个 item）状态更新时：
- React 开始递归遍历整个组件树
- 每个组件执行 `render()`，生成 VDOM
- 对比新旧 VDOM，计算出 DOM 变更
- 最后批量更新真实 DOM
过程可能持续 100ms+ 。这是一个同步，阻塞 js 计算，在此期间浏览器被 js 线程占用，ui 渲染线程暂停，鼠标的移动，用户输入无法执行。新的更新必须**等待当前任务完成**才能开始导致浏览器停止响应一段时间，观察到卡顿。

React16+ 的 Fiber 架构通过 可中断的渲染与增量渲染 (Incremental Rendering)，任务优先级调度 (Priority-based Scheduling)，双缓存 (Double Buffering) Fiber 树 解决之前的问题。

**可中断的渲染与增量渲染 (Incremental Rendering)**，当触发一个 `setState` 操作时遍历整个组件树，计算出每个组件的新状态和需要生成的虚拟 DOM (VDOM)，然后进行 Diff 比较，最后生成需要应用到真实 DOM 的更新指令。如果组件树非常复杂，这个同步递归过程可能持续上百毫秒。Incremental Rendering 将上百毫秒的更新操作拆分为多个工作单元，在当前帧 ui 线程执行完时检查还省多少时间，60fps 需要每帧 16.6ms，ui 渲染可能需要 8ms，剩余 8.6ms 用于 js 线程计算 react 更新。当前帧时间结束暂停计算，到下一帧剩余时间继续执行，直到计算完成。这个特性保证 react 在处理复杂组件时可以同时响应用户操作，但不会加速 `setState` 操作更新速度。

React Fiber 的“可中断渲染”
**本质上就是在单线程的 JavaScript 环境中，模拟了操作系统在单核 CPU 上实现多任务并发的“时间分片”调度思想。**
- **单核 CPU** 通过时间分片让多个**独立程序**看似并行运行。
- **React Fiber** 通过时间分片让一个**耗时的渲染任务**和**高优先级的用户交互任务**看似并发运行。

**任务优先级调度 (Priority-based Scheduling)**，在 React 15 中，所有的状态更新 `setState` 是“平等”的。无论是一个紧急的用户点击反馈，还是一个后台的数据加载，React 都会以相同的方式处理，这可能导致关键的交互响应被延迟。Fiber 根据更新的**来源**和**目的**，为每个更新任务赋予不同的优先级。调度器（Scheduler）会根据这些优先级来决定：
-  **哪个任务应该先执行？** （高优先级任务抢占低优先级任务）
-  **当前正在进行的低优先级任务是否应该被中断？** （为更高优先级任务让路）
-  **任务应该在何时被执行？** （立即、下一帧、空闲时等）
使得 React 能够优先保证对用户最敏感、最需要即时反馈的操作

**双缓存 (Double Buffering) 与 Fiber 树**，在 React 15 的同步递归模型中：
- 一旦开始 `render`，就直接在当前的组件实例和虚拟 DOM 树上进行修改。
- 这个过程是**破坏性的**：在更新完成前，树处于一个“中间”或“不一致”的状态。
- 因为过程不可中断，这种不一致状态对外不可见。
- 但这也意味着**无法中断**：一旦开始，必须完成，否则会留下一个损坏的、无法使用的树。

**Fiber 的挑战**：既然 `render` 阶段要变成可中断、可恢复的，就必须解决“中间状态”的问题。如果在构建新 UI 的过程中被中断，当前的 UI 树不能处于一个半新半旧的、不一致的状态，否则用户会看到错误的 UI，或者 React 自身会崩溃。

**Fiber 解决方案**：双缓存。React 同时维护两棵 Fiber 树：
- **`current` 树 (当前树)**：代表**当前正在屏幕上渲染的 UI**。这棵树是稳定、一致、可随时用于渲染的。
- **`workInProgress` 树 (进行中树)**：代表**正在内存中构建的新版本 UI**。所有的计算、状态更新、Diff 比较都在这棵树上进行。
当 render 阶段完成将 `fiberRoot.current` 是一个指向当前 `current` 树根 Fiber 节点的指针，从 current fiber 移动到 workInProgress fiber 并 commit 更改调用浏览器接口修改真实 DOM。

Fiber Tree 不是常规的嵌套递归树形结构，而是通过链表模拟的类树形结构。底层是链表，但其逻辑拓扑结构仍然是一个树，只是遍历和操作的方式完全不同。

useState 无法同步修改数据的原因在双 Fiber 树处理上，由于 workInProgress fiber tree 是可中断和恢复的，导致 workInProgress fiber tree 无法同步更新 ->`fiberRoot.current` 无法指向 workInProgress fiber tree 更新为 current fiber tree ->无法从 fiber 节点获取更新的值。介绍 useState 功能时描述为获取数据快照本质是从当前 current fiber tree 获取数据，setState 更新状态导致的 fiber tree 更新就是生成新快照。


状态不属于函数，而属于对应的 Fiber 节点。函数只是从 FIber 树读取状态 + 生成 UI
函数组件是无状态的渲染器 
Fiber 节点是有状态的容器
Reat 上对状态的操作实际上都是操作 Fiber Tree 上的数据节点。
React 中没有实际意义上的虚拟 DOM 树，只有双 Fiber Tree。只是通过元素对应的虚拟 DOM 节点创建对应的 Fiber 节点，并构建 FIber Tree。

## 8.28

### React 设计哲学

**数据更新 Immutable**，替换数据而不要修改数据。
告诉 React 想变成什么样，它帮你更新

### React 和 Vue 一些简单对比

**数据更新** 和 **视图更新** 机制上的核心差异。
React 中数据不是立即改变的，状态更新和视图更新是绑定的，状态更新和视图更新在同一次渲染中完成，不会出现获取到新数据，试图未更新情况。
Vue 同步更新数据，`count.value = 1` 立即修改数据，同时 Vue 检测到数据改变在 nextTick 时执行 UI 更新，两者在时间上分离，可能会出现获取到新数据，试图未更新情况。

``` vue
<template>
  <div>{{ count }}</div>
</template>

<script setup>
const count = ref(0)
count.value = 1

// 此时 DOM 还是旧状态
console.log(document.querySelector('div').textContent) // 0

// 等到 nextTick，DOM 才更新
nextTick(() => {
  console.log(document.querySelector('div').textContent) // 1
})
</script>
```

数据操作的细微差别
React 中通知 React 想要更新 UI 为什么样式
``` jsx
function Counter({ count }) {
  return (
    <div>
      <p>Count: {count}</p>
      %% 通知React想要更新 %%
      <button onClick={() => setCount(count + 1)}>
        更新按钮
      </button>
    </div>
  );
}
```

Vue 中直接修改数据，Vue 检测到数据变化并更新 UI
``` jsx
<template>
  <div>
    <p>Count: {{ count }}</p>
    <button @click="increment">
      更新按钮
    </button>
  </div>
</template>

<script setup>
import { ref } from 'vue'

const count = ref(0)

function increment() {
  count.value++ // 你直接修改数据
}
</script>
```

两者最终都实现了声明式 UI
- React 更“函数式”：**输入 → 输出**。用户负责描述 UI，React 负责同步状态与 UI
- Vue 更“响应式”：**数据变 → 视图变**。用户负责改数据，Vue 监听变化并更新 UI

## 9.11

静态结构、复杂交互 → 用组合式（shadcn 原生方式）
动态结构、标准化展示 → 用配置对象

shadcn 不反对配置式，它反对的是不可控的配置式
- Ant Design 的 `<Table columns={...} />` 是一个**黑盒配置**：你只能通过 props 影响它，不能改变它的内部结构。
- 而 shadcn 的 `<DataTable columns={...} />` 是一个**白盒配置**：你封装的这个组件，内部是透明的，你可以随时打开修改。

依赖 “组合” 而非 “封装”

## 9.21

前后端在类型系统领域似乎有些差异。在后端领域，如 JAVA，GO 中通过继承，组合，泛型等机制构建的类型系统，能够为多场景需求提供可预测的结构化服务，即开发阶段可以知道所有可能执行的分支。但在前端领域，虽然可以 TS 定义类型，但程序状态常通过数据驱动更新，如根据用户权限（管理员，用户）表格展示不同字段，根据编辑状态（草稿，编辑，审查）表单渲染不同字段和校验逻辑。这类运行时确定状态和 TS 的静态类型检查有一定冲突。TS 如何解决这类问题？

核心为**用静态类型描述所有可能性，用运行时逻辑控制渲染行为**实现开发时类型安全和运行时状态切换。

- **联合类型枚举可能状态**+ 分支渲染
	类型定义限制了可能执行的分支，开发时可了解所有执行分支的边界。但该方案仅限较少状态分支，如果 role × mode × permissions × ...... 需要编写大量渲染分支且拓展性较低。
``` JSX
 type Status = 'loading' | 'success' | 'error'; 
 type Role = 'admin' | 'user' | 'guest';

function isAdmin(user: User) {
	if(user.role === 'admin') {
		return <AdminUI>
	}
	if(user.role === 'user') {
		return <UserUI>
	}
}
```
- 泛型通用组件
	泛型定义所有可能状态，开发时可了解所有执行分支的边界


### 前后端类型系统的差异

- **执行环境不同**
	后端程序是“服务提供者”，它的行为由 API 请求驱动，**入口有限且明确**。
	前端程序是“状态机”，它的行为由**用户点击、网络请求、权限变化等事件实时驱动**。导致前端的状态是**动态组合、不可穷尽**的。如 role × mode × permissions × locale 可组合出大量状态。
	
- **程序状态模型不同**
	后端：类 + 方法 + 继承（面向对象，状态静态）/ 组合，所有子类在编译期已知，状态变化有限。
	前端：数据驱动 UI（函数式 + 响应式，状态动态），行为由数据驱动，不同数据驱动执行不同 UI 渲染分支。
	
- **类型系统的职责不同**
	Java 的类型是运行时的一部分（如 `instanceof`、泛型擦除前的类型信息）
	TypeScript 的类型是**开发时的辅助工具**，编译后消失。所以 TS 类型系统为开发者划出一块“可预测的安全区”，可在快速变化的 UI 逻辑中，依然能自动补全，安全重构。

## 9.22

解构仅赋值对象可枚举属性，不包括原型方法，即如果 `CustomFile extends File` 解构对象时无法获得 File 原生 toArraryBuffer，toBinary 等方法。

## 10.1

如果从代码层面跳出，从更高的角度思考软件开发，似乎从全局上更能做到模块分层，领域分类。
比如 `<Input>` 标签希望在 `onChange` 回调函数中过滤一些非法字符串。比如，金额输入框，希望输入非负、数字 内容；电话号码输入框，希望输入数字、最大位数 11 位内容；用户名输入框，希望输入非空格内容。这些为通用过滤逻辑可以封装为通用函数。

``` typescript
const InputFIlter = {
  string(): StringFilter {},

  number() {
    const filters: Filter[] = [];

    const chain = {
      integer: () => {
        filters.push((value) => value.replace(/[^\d]/g, ""));
        return chain;
      },
      
      nonNegative() {
        filters.push((value) => value.replace(/-/g, ""));
        return chain;
      },
      
      maxLength(max: number) {
        filters.push((value) => value.slice(0, max));
        return chain;
      },
      
      exec: (): ((value: string) => string) => {
        return (value: string) =>
          filters.reduce((result, fn) => fn(result), value);
      },

	%% 最大值限制 %%
	%% 最小值限制 %%
    };
    return chain;
  },
};
export default InputFIlter;

%% 使用方式 %%
const phoneFilter = fz.number() .integer() .noSpace() %% 限制输入数字，整形，无空格 %%
```
从代码层面 `InputFIlter` 问题不大，但从业务层面未完全定位职责。`InputFIlter` 用于在输入过程中，**实时清理非法字符**，保证输入框只显示合法内容。如果使用 max(),min() 实时检查输入是否符合规则并修改输入，不符合非法字符过滤器的定位。 最大最小值校验应该在 zod 中执行。

在组件开发时注意该组件为受控组件还是非受控组件，不同类型组件在交互和数据传递时有不同使用范式。

## 10.2

Hydration(水合) 是服务端渲染中的概念，在客户端，将一个由服务端生成的静态 HTML 页面，“激活”为一个具备完整交互能力的动态 React 应用的过程。即将静态页面和 react 动态交互能力对接，比如 SSR 渲染 MyButton 组件为静态 html `<button>Click me</button>`,button 不具有动态交互能力，此时 Hydration 将 React 的 hooks 等动态交互功能与 html 绑定。
SSR 颗粒度为组件，以组件为单位控制是否在服务端渲染。
``` typescript
function MyButton() { 
	const handleClick = () => alert('Clicked!'); 
	return <button onClick={handleClick}>Click me</button>; 
}
```
现代 react 性能足够，除了复杂工程的首屏渲染，很多情况不需要 SSR，所以使用 SSR 的思想不止考虑渲染复杂度，而是执行环境或者说数据。这个组件是否需要在服务端获取数据或执行敏感逻辑？具体使用业务场景还在思考。

## 10.16

前端组件分层设计范
别再把 Component 当页面碎片。看似将用户相关UI写到一个组件中和其他比如 TradingList, Dashboard 组件分隔。但UserProfile组件内部所有职责混在一起：
- 数据获取逻辑
- 状态管理
- UI 渲染
- 用户交互
导致复杂UI组件代码行数过多，拓展性不足等多种问题。
``` JSX
function UserProfile() {
	const [user, setUser] = useState(null);
	%% 状态管理 %%
	const [loading, setLoading] = useState(false);
	
	%% 数据获取逻辑 %%
	  useEffect(() => {
	    setLoading(true);
	    fetch('/api/user/123')
	      .then(res => res.json())
	      .then(data => setUser(data))
	      .finally(() => setLoading(false));
	  }, []);
	
	%% 用户交互 %%
	  const handleUpdate = async (newData) => {
	    const res = await fetch('/api/user/123', {
	      method: 'PUT',
	      body: JSON.stringify(newData)
	    });
	    setUser(await res.json());
	  };
	
	%% UI 渲染 %%
	  if (loading) return <div>Loading...</div>;
	
	%% UI 渲染 %%
	  return (
	    <div className="profile">
	      <h1>{user?.name}</h1>
	      <p>{user?.phone}</p>
	      <button onClick={() => handleUpdate({...user, vip: true})}>
	        升级VIP
	      </button>
	    </div>
	  );
}
```

参考后端代码组织风格，对一个接口分为Controller，Service，Repository使不同职责代码相互不影响。
- 纯粹的业务逻辑和数据交互
- 状态管理和副作用编排
- 纯展示组件
``` JSX
export const userService = {  
	async getUser(userId) {  
	    const response = await fetch(`/api/user/${userId}`);  
	    if (!response.ok) {  
	      thrownewError(`Failed to fetch user: ${response.status}`);  
	    }  
	    return response.json();  
    },  
	  
	async updateUser(userId, updates) {  
	    const response = await fetch(`/api/user/${userId}`, {  
	      method: 'PUT',  
	      headers: { 'Content-Type': 'application/json' },  
	      body: JSON.stringify(updates)  
	    });  
	    if (!response.ok) {  
	      thrownewError(`Failed to update user: ${response.status}`);  
	    }  
	    return response.json();  
	  }  
	};  
}  

// 第二层:Behavior Layer - 状态管理和副作用编排   
export function useUserProfile(userId) {  
	const [user, setUser] = useState(null);  
	const [loading, setLoading] = useState(false);  
	const [error, setError] = useState(null);  
	  
	const loadUser = useCallback(async () => {  
	    setLoading(true);  
	    setError(null);  
	    try {  
	      const data = await userService.getUser(userId);  
	      setUser(data);  
	    } catch (err) {  
	      setError(err);  
	    } finally {  
	      setLoading(false);  
	    }  
	  }, [userId]);  
	  
	const updateUser = useCallback(async (updates) => {  
	    try {  
	      const updated = await userService.updateUser(userId, updates);  
	      setUser(updated);  
	      return { success: true };  
	    } catch (err) {  
	      setError(err);  
	      return { success: false, error: err };  
	    }  
	  }, [userId]);  
	  
	  useEffect(() => {  
	    loadUser();  
	  }, [loadUser]);  
	  
	return { user, loading, error, updateUser, reload: loadUser };  
}
  
// 第三层:UI Layer - 纯展示组件  
export function UserProfile({ userId }) {  
	const { user, loading, error, updateUser } = useUserProfile(userId);  
	  
	if (loading) return<LoadingSpinner />;  
	if (error) return<ErrorMessage error={error} />;  
	if (!user) returnnull;  
	  
	return (  
	    <ProfileCard   
	      user={user}   
	      onUpgradeVip={() => updateUser({ vip: true })}   
	    />  
	);  
}
```

